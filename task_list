(*future)
* rename the project to GLock, (pronounced like the gun, Glock, short for Generalized-Lock)
* this will obviously house the rwlock
* but it will also contain a glock, a type of generalized lock for complex data structures
  * allowing users to input and pass a lock compatibility matrix (a square matrix of NxN, N being the number of operations uniquely defined on the data structure) where 1 means, 2 operation are allowed together, else they block each other
  * matrix[M1][M2] -> 0 OR 1, tells me if lock request with mode = M1 could grab the lock, while a lock for mode = M2 has already been issued
  * it will like the rwlock, allow external_lock and internal_lock
  * will maintain a counter of all issued locks, each grouped by their modes and a single condition variable that is woken up whenever a lock is released
  * a mutex will have lock compatibility matirx as below (if implemented using glock)
           LOCK
    LOCK   0
  * a rwlock's lock compatibility matrix, in terms of glock could possibly look like this
           Read  Write
    Read   1     0
    Write  0     0
  * simple api (will mke it complex as more of it is designed)
    * int glock_lock(glock* glock_p, int mode, uint64_t timeout_in_microseconds); (same BLOCKING and NON_BLOCKING constant macros will be allowed here)
    * int glock_transition_lock(glock* glock_p, int old_mode, int new_mode);
    * int glock_unlock(glock* glock_p, int mode);
  * there will also be int initialize_glock(glock* glock_p, const lock_compatibility_matrix*) and void deinitialize_glock(glock* glock_p) functions
  * lock_compatibility_matrix {
    int modes_count;
    int** matrix; // 2d array of size (modes_count * modes_count), ith row (0-indexed) must atleast have (i+1) elements
  }
  * need to ensure that this matrix is symmettric accross its [0][0] to [modex_count-1][modes_count-1] diagonol, make a function for this
  * need a function to check if 2 lock_modes are compatible, they are compatible if matirx[max(m1,m2)][min(m1,m2)] == 1
  * glock {
    const lock_compatibility_matrix* lcm;

    int has_internal_lock : 1;
    union{
      pthread_mutex_t internal_lock;
      pthread_mutex_t* external_lock;
    };

    uint64_t* lock_granted_count_per_modex; // array of size modes_count

    pthread_cond_t waiters_wait;
  }
  * rwlock WILL NEVER BE IMPLEMENTED AS A GENERALIZED CASE OF glock, BECAUSE
    * glock will not have separate condition variable for all locking operation types, so can not prevent thread thrashing
    * and no read/write preferring options
    * no upgrade-downgrade options
    * glock needs to intialize a dynamic array for counts of locks issued per operation type, which is not ideal, and so it's initialization could fail, unlike rwlock