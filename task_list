(*future)
* this will obviously house the rwlock
* but it will also contain a glock, a type of generalized lock for complex data structures
  * allowing users to input and pass a lock compatibility matrix (a square symmetric matrix of NxN, N being the number of locking modes uniquely defined on the data structure) where 1 means, 2 modes are compatible for being concurrently held, else they block each other
  * it will like the rwlock, allow external_lock and internal_lock
  * will maintain a counter of all issued locks, each grouped by their modes and a single condition variable that is woken up whenever a lock is released
  * a mutex will have lock compatibility matirx as below (if implemented using glock)
           LOCK
    LOCK   0
  * a rwlock's lock compatibility matrix, in terms of glock could possibly look like this
           Read  Write
    Read   1     0
    Write  0     0
  * simple api (will mke it complex as more of it is designed)
    * int glock_lock(glock* glock_p, int mode, uint64_t timeout_in_microseconds); (same BLOCKING and NON_BLOCKING constant macros will be allowed here)
    * int glock_transition_lock_mode(glock* glock_p, int old_mode, int new_mode);
    * int glock_unlock(glock* glock_p, int mode);
  * there will also be int initialize_glock(glock* glock_p, const lock_compatibility_matrix*) and void deinitialize_glock(glock* glock_p) functions
  * lock_compatibility_matrix {
    uint16_t modes_count; // upto 64000 modes allowed
    uint8_t* matrix;
  }
  total number of elements in matix = (modes_count) * (modes_count + 1) / 2
  lock_compatibility_matrix[i][j] = lock_compatibility_matrix[j][i] = matrix[ min(i,j) + (max(i,j) * (max(i,j)+1)) / 2];
  for all 0 <= i, j < modes_count
  * a template initialization of this lock_compatibility matrix should look like this
  lock_compatibility_matrix m = {
    3,
    (uint8_t[ (3 * (3+1)) / 2 ]){
          0,
          1,2,
          3,4,5
    },
  };
  * need a function to check if 2 lock_modes are compatible, they are compatible if lock_compatibility_matrix[m1][m2] == 1
  * glock {
    const lock_compatibility_matrix* lcm;

    int has_internal_lock : 1;
    union{
      pthread_mutex_t internal_lock;
      pthread_mutex_t* external_lock;
    };

    uint64_t* lock_granted_count_per_mode; // array of size modes_count

    uint64_t waiters_count; // total number of waiter threads waiting

    pthread_cond_t waiters_wait;
  }
  * In readme add the following:
   * WHEN A rwlock CAN BE IMPLEMENTED USING THE glock, THEN WHY IS THERE A SEPARATE IMPLEMENTATION FOR A rwlock?
   * Why rwlock WILL NEVER BE IMPLEMENTED AS A GENERALIZED CASE OF glock?
     * glock will not have separate condition variable for all locking modes, so can not prevent thread thrashing
     * glock will not have read/write preferring options
     * glock_transition_lock_mode may allow upgrade/downgrade, but does not protect against deadlock caused by 2 concurrent readers trying to upgrade the same reader lock, while rwlock gracefully fails such a case by only allowing exactly 1 thread to wait for upgrading the reader lock
     * glock needs to allocate and intialize a dynamic array for counts of locks issued per lock mode, and so it's initialization could fail, unlike rwlock
  * update this project in resume